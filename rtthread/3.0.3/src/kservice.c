#include <rtthread.h>

/*
* __lowest_bit_map[]	数组解析
* 将一个8位整型数的取值范围0-255作为数组的索引，
* 索引值第一个出现1（从最低位开始）的位号作为该数组索引下的成员值。
*	举例：十进制数10的二进制为：0000 1010，从最低位开始，
*	第一个出现1的位号为bit1，则有__lowest_bit_map[10] = 1
* 注意：只要找到第一个出现1的位号即可
*/
const rt_uint8_t __lowest_bit_bitmap[]= 
{
	/* 位号 */
	/* 00 */	0,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/* 10 */	4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/* 20 */	5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/* 30 */	4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/* 40 */	6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/* 50 */	4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/* 60 */	5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/* 70 */	4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/* 80 */	7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/* 90 */	4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/* A0 */	5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/* B0 */	4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/* C0 */	6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/* D0 */	4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/* E0 */	5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/* F0 */	4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
};

char *rt_strncpy(char *dst, const char *src, rt_ubase_t n)
{
	if(n != 0)
	{
		char *d = dst;
		const char *s = src;
		
		do
		{
			if((*d++ = *s++) == 0)
			{
				/* NUL pad the remaining n-1 butes */
				while(--n != 0)
						*d++ = 0;
				break;
			}
		}
		while(--n != 0);
	}
	
	return (dst);
}

/* 寻找一个32位的数中第一个被置1的位（低位开始），返回该位的索引号 */
int __rt_ffs(int value)
{
	/* 如果值为0，则直接返回0 */
	if(value == 0)	return 0;
	
	/* 检查 bits [07 : 00] */
	if(value & 0xff)
		return __lowest_bit_bitmap[value & 0xff] + 1;
	
	/* 检查 bits [15 : 08] */
	if(value & 0xff00)
		return __lowest_bit_bitmap[(value & 0xff00) >> 8] + 9;
	
	/* 检查 bits [23 : 16] */
	if(value & 0xff0000)
		return __lowest_bit_bitmap[(value & 0xff0000) >> 16] + 17;
	
	/* 检查 bits [31 : 24] */
	return __lowest_bit_bitmap[(value & 0xff000000) >> 24] + 25;
}
